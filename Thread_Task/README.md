# 쓰레드와 테스크

## 프로세스 개요

최근 운영체제는 여러 프로세스를 동시에 실행할 수 있는 능력을 갖추고 있다. 프로세스 또한 한번에 여러 작업을 할 수 있다. 프로세스란 실행 파일이 실행되어 메모리에 적재된 인스턴스이다. 가령 word.exe가 실행 파일이라면, 이 실행 파일에 담겨 있는 데이터와 코드가 메모리에 적재되어 동작하는 것이 프로세스이다. 프로세스는 반드시 하나 이상의 스레드로 구성되는데, 스레드는 운영체제가 CPU 시간을 할당하는 기본 단위이다.

## 멀티 스레드 장단점

### 장점

1. 첫 번째 장점으로 사용자 대화형 프로그램에서 (콘솔 프로그램과 GUI 프로그램 모두) 멀티 스레드를 이용하면 응답성을 높일 수 있다.

> 예를 들어 단일 스레드를 사용하는 프로그램을 만들었고, 이 프로그램에서 파일 복사만 30분이 걸린다고 하자. 사용자가 파일 복사를 취소하고 싶어도 프로그램은 사용자에게 반응하지 않아서 복사를 취소할 수 없다. 작업관리자를 이용해서 강제로 프로세스를 종료시키지 않는 이상.

따라서 이 프로그램에 사용자와의 대화를 위한 스레드를 하나 더 추가한다면 파일 복사를 하면서도 사용자로부터 명령을 입력받을 수 있다.

2. 두 번째 장점으로는 멀티 프로세스 방식에 비해 멀티 스레드 방식이 자원 공유가 쉽다는 것이다.  
   멀티 프로세스는 GUI가 없는 웹 서버 같은 서버용 어플리케이션이 많이 취하는 구조인데, 프로세스끼리 데이터를 교환하려면 소켓이나 공유 메모리 같은 IPC를 이용해야 한다. 반면에 멀티 스레드 방식에서는 그저 스레드끼리 코드 내의 변수를 같이 사용하는것만으로도 데이터 교환을 할 수 있다.

3. 멀티 프로세스 방식에 비해 멀티 스레드 방식의 좋은 점이 또 하나 있다. 바로 "경제성"이다. 프로세스를 띄우기 위해 메모리와 자원을 할당하는 작업은 ( CPU 사용 시간 등의 ) 비용이 비싼데, 스레드를 띄울 때는 이미 프로세스에 할당된 메모리와 자원을 그대로 사용하므로 메모리와 자원을 할당하는 비용을 지불하지 않아도 된다.

### 단점

1. 멀티 스레드 구조의 소프트웨어는 구현하기가 매우 까다롭다. 테스트 역시 쉽지 않고 멀티 스레드 기반의 소프트웨어 디버깅은 매우 힘들다.

2. 멀티 '프로세스' 기반의 소프트웨어는 여러 개의 자식 프로세스 중 하나에 문제가 생기면 그 자식 프로세스 하나가 죽는 것 이상으로는 영향이 확산되지 않지만, 멀티 '스레드' 기반의 소프트웨어는 자식 스레드 중 하나에 문제가 생기면 전체 프로세스에 영향을 준다.

3. 멀티 스레드 마지막 단점은, 장점이자 단점인데 바로 성능이다. 스레드를 너무 많이 사용하면 오히려 성능이 더 저하된다. 스레드가 CPU를 사용하기 위해서는 작업 간 전환을 해야 하는데, 이 작업 간 전환이 비용을 소모한다. 많은 스레드가 너무 자주 작업 간 전환을 수행하다 보면 애플리케이션이 실제로 일하는 시간에 비해 작업 간 전환에 사용하는 시간이 커지기 때문에 성능이 저하된다.

### 장단점 요약 정리

장점

1. 응답성을 높일 수 있다.
2. 자원 공유가 쉽다.
3. 경제적이다.

단점

1. 구현이 복잡하다.
2. 소프트웨어 안정성을 약화시킬 수 있다.
3. 과용하면 성능이 저하될 수 있다.

## 스레드 시작하기

C#에서 스레드를 쓰기 위해 .NET은 스레드를 제어하는 클래스로 System.Threading.Thread를 제공한다.

1. Thread의 인스턴스를 생성한다. 이때 생성자의 인수로 스레드가 실행할 메소드를 넘긴다.
2. Thread.Start() 메소드를 호출하여 스레드를 시작한다.
3. Thread.Join() 메소드를 호출하여 스레드가 끝날 때까지 기다린다.

## 스레드 임의로 종료시키기

사용자가 작업 관리자 등을 이용해서 프로세스를 임의로 죽일수 있지만, 프로세스 안에서 동작하는 각 스레드는 그런식으로 죽일 수 없다.
살아 있는 스레드를 죽이려면 Thread 객체의 Abort() 메소드를 호출해줘야 한다.

### Abort() 메소드 사용시 고려사항

Abort() 메소드는 호출과 동시에 스레드를 즉시 종료하지 않는다. Thread 객체에 Abort() 메소드를 호출하면 CLR은 해당 스레드가 실행 중이던 코드에 ThreadAbortException을 던진다. 이때 이 예외를 catch 하는 코드가 있으면 이 예외를 처리한 다음, finally 블록까지 실행한 후에야 해당 스레드는 완전히 종료된다.

> Abort() 함수는 사용하지 않는 것이 좋다. 스레드가 동기화를 위해 어떤 자원을 독점하고 잠근 후 자원을 해제하지 못한채 Abort() 메소드를 호출 당해 죽어버리면, 그 자원에 접근하고자 하는 다른 스레드들은 꼼짝 못하는 신세가 된다.

## 스레드의 일생과 상태 변화

| 상태          | 설명                                                                                                                                                                                                                                                                                                                                                                       |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Unstarted     | 스레드 객체를 생성한 후 Thread.Start() 메소드가 호출되지 전의 상태입니다.                                                                                                                                                                                                                                                                                                  |
| Running       | 스레드가 시작하여 동작 중인 상태를 나타낸다. Unstarted 상태의 스레드를 Thread.Start() 메소드를 통해 이 상태로 만들 수 있습니다.                                                                                                                                                                                                                                            |
| Suspended     | 스레드의 일시 중단 상태를 나타낸다. 스레드를 Thread.Suspend() 메소드를 통해 이 상태로 만들 수 있으며, Suspended 상태인 스레드는 Thread.Resume() 메소드를 통해 다시 Running 상태로 만들 수 있다.                                                                                                                                                                            |
| WaitSleepJoin | 스레드가 블록(Block)된 상태를 나타낸다. 이름이 Blocked가 아니고 WaitSleepJoin인 이유는 스레드에 대해 Monitor.Enter(), Thread.Sleep() 또는 Thread.Join() 메소드를 호출하면 이 상태가 되기 때문이다.                                                                                                                                                                         |
| Aborted       | 스레드가 취소된 상태를 나타낸다. Thread.Abort() 메소드를 호출하면 이 상태가 된다. Aborted 상태가 된 스레드는 다시 Stopped 상태로 전환되어 완전히 중지된다.                                                                                                                                                                                                                 |
| Stopped       | 중지된 스레드의 상태를 나타낸다. Abort() 메소드를 호출하거나 스레드가 실행 중인 메소드가 종료되면 이 상태가 된다.                                                                                                                                                                                                                                                          |
| Background    | 스레드가 백그라운드로 동작하고 있음을 나타낸다. 포어그라운드(Foreground) 스레드는 하나라도 살아 있는 한 프로세스가 죽지 않지만, 백그라운드는 하나가 아니라 열 개가 살아 있어도 프로세스가 죽고 사는 것에 영향을 미칠 수 없다. 하지만 프로세스가 죽으면 백그라운드 스레드들 모두 죽는다. Thread.ISbackground 속성에 true 값을 입력함으로써 스레드를 이 상태로 바꿀 수 있다. |

스레드 상태 사이클
![스레드 상태 사이클](https://user-images.githubusercontent.com/67315288/147529508-8b0b1b96-d796-4ce8-bf07-71de676bb6a2.png)

ThreadState에 Flags 애트리뷰트를 갖고 있다. Flags는 자신이 수식하는 열거형을 비트 필드, 즉 플래그 집합으로 처리할 수 있음을 나타낸다.

> 비트 필드란 ?
> 비트 필드는 원래 C 언어 등에서 구조체를 선언할 때 바이트 단위가 아닌 비트 단위로 선언한 필드를 말하는데, 주로 비트 단위의 플래그를 표현하기 위해 사용했다. C언어가 1970년대 초에 만들어졌고 그 당시의 메모리 가격과 용량을 생각하면 비트 필드의 구조를 고민 할 수 밖에 없었을 것이다.
> 이와 같이 현재는 메모리와 프로세서의 용량이 매우 커지게 되면서 비트 필드와 같은 번거로운 문법을 지원 안하지만 C# 에서는 적용할수 있게 .NET에 Flags 애트리뷰트를 선언해 두었다.

